"use server";

import { redirect } from "next/navigation";
import { revalidatePath } from "next/cache";
import { auth, currentUser } from "@clerk/nextjs";

import { getCourseById } from "@/lib/data";
import { POINTS_TO_REFILL } from "@/constants";

// In-memory storage for user progress
// Note: In a production environment, you might want to use a more persistent solution
let userProgressStore: { [key: string]: any } = {};

export const getUserProgress = async () => {
  const { userId } = await auth();

  if (!userId) {
    throw new Error("Unauthorized");
  }

  return userProgressStore[userId] || null;
};

export const upsertUserProgress = async (courseId: string) => {
  const { userId } = await auth();
  const user = await currentUser();

  if (!userId || !user) {
    throw new Error("Unauthorized");
  }

  const course = getCourseById(courseId);

  if (!course) {
    throw new Error("Course not found");
  }

  if (!course.units.length || !course.units[0].lessons.length) {
    throw new Error("Course is empty");
  }

  const newProgress = {
    userId,
    activeCourseId: courseId,
    userName: user.firstName || "User",
    userImageSrc: user.imageUrl || "/mascot.svg",
    hearts: 5,
    points: 0,
    streak: 0,
  };

  userProgressStore[userId] = newProgress;

  revalidatePath("/courses");
  revalidatePath("/learn");
  redirect("/learn");
};

export const reduceHearts = async () => {
  const { userId } = await auth();

  if (!userId) {
    throw new Error("Unauthorized");
  }

  const currentUserProgress = await getUserProgress();

  if (!currentUserProgress) {
    throw new Error("Progress not found");
  }

  if (currentUserProgress.hearts === 0) {
    return false;
  }

  userProgressStore[userId] = {
    ...currentUserProgress,
    hearts: currentUserProgress.hearts - 1,
  };

  revalidatePath("/learn");
  revalidatePath("/learn/lesson");
  revalidatePath("/shop");
  return false;
};

export const refillHearts = async () => {
  const { userId } = await auth();

  if (!userId) {
    throw new Error("Unauthorized");
  }

  const currentUserProgress = await getUserProgress();

  if (!currentUserProgress) {
    throw new Error("Progress not found");
  }

  if (currentUserProgress.points < POINTS_TO_REFILL) {
    throw new Error("Not enough points");
  }

  userProgressStore[userId] = {
    ...currentUserProgress,
    hearts: 5,
    points: currentUserProgress.points - POINTS_TO_REFILL,
  };

  revalidatePath("/learn");
  revalidatePath("/learn/lesson");
  revalidatePath("/shop");
};

export const updatePoints = async (points: number) => {
  const { userId } = await auth();

  if (!userId) {
    throw new Error("Unauthorized");
  }

  const currentUserProgress = await getUserProgress();

  if (!currentUserProgress) {
    throw new Error("Progress not found");
  }

  userProgressStore[userId] = {
    ...currentUserProgress,
    points,
  };

  revalidatePath("/learn");
  revalidatePath("/learn/lesson");
  revalidatePath("/shop");
  revalidatePath("/quests");
};

export const updateStreak = async () => {
  const { userId } = await auth();

  if (!userId) {
    throw new Error("Unauthorized");
  }

  const currentUserProgress = await getUserProgress();

  if (!currentUserProgress) {
    throw new Error("Progress not found");
  }

  userProgressStore[userId] = {
    ...currentUserProgress,
    streak: (currentUserProgress.streak || 0) + 1,
  };

  revalidatePath("/learn");
  revalidatePath("/learn/lesson");
  revalidatePath("/shop");
  revalidatePath("/quests");
};
